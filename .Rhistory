install.packages("devtools")
install.packages("roxygen2")
randomize = function(shipment_manifest_excel,
api_metadata_csv,
max_n_per_batch,
strict_size,
max_full_batches,
vars_to_balance,
outdir,
verbose,
max_inner_loop_iter,
max_outer_loop_iter,
overwrite,
balance_strictness,
tissue_subset,
block_randomization,){
stop(paste("This script is not currently designed for cases where *both* --max-full-batches and --strict-size are TRUE.",
"Please use only one of the two flags. --strict-size should be used for small batches, e.g. --max-n-per-batch < 20;",
"--max-full-batches should be used for larger batches where the user wants to maximize the number of batches with exactly",
"--max-n-per-batch samples."))
install.packages("roxygen2")
roxygenise()
library(roxygen2)
roxygenise()
warnings()
make_batches_strict = function(curr_batch_pid, b, max_n_per_batch, balance_strictness, max_full,
balance_vars = c('codedsiteid','randomgroupcode','sex_psca'),
verbose=T){
feasible_batches = FALSE
n_samples_per_pid = curr_batch_pid[,N]
names(n_samples_per_pid) = curr_batch_pid[,pid]
n_samples_per_pid = as.list(n_samples_per_pid)
# first try to find batches with ideal batch size
batch_sizes = id_optimal_batch_sizes(curr_batch_pid, max_n_per_batch, max_full)
# keep track of which variables are failing balancing
if(max_full){
failed_balancing = list()
for(v in balance_vars){
failed_balancing[[v]] = 0
}
}
# is it possible to make batches of this size? give up after 1e6 tries
outer_loop = 1
inner_loop = 1
balanced_batches = F
while(!balanced_batches){
# set up batches
new_sets = list()
for(i in 1:length(batch_sizes)){
new_sets[[i]] = list()
}
remaining_room_per_batch = batch_sizes
names(remaining_room_per_batch) = 1:length(remaining_room_per_batch)
# randomly reorder n_samples_per_pid
n_samples_per_pid_reordered = n_samples_per_pid[sample(1:length(n_samples_per_pid), length(n_samples_per_pid), replace=F)]
while(!all(remaining_room_per_batch==0)){ # while there are samples left to place...
# extract the first set
set_to_place = n_samples_per_pid_reordered[1]
# put this in the first batch that it fits
batch_to_place = as.numeric(names(remaining_room_per_batch)[remaining_room_per_batch>=set_to_place][1])
if(is.na(batch_to_place)){
break
}
new_sets[[batch_to_place]] = c(new_sets[[batch_to_place]], set_to_place)
remaining_room_per_batch[[batch_to_place]] = remaining_room_per_batch[[batch_to_place]] - unlist(set_to_place)
n_samples_per_pid_reordered = n_samples_per_pid_reordered[-1] # only remove the sample after it's been placed
}
# this worked?
if(all(remaining_room_per_batch==0)){
# only print once in a while if inner_loop is small
if(inner_loop < 100){
pmessage = outer_loop %% 100 == 0
}else{
pmessage = T
}
if(verbose & pmessage){
message(sprintf("Identified the %sth combination of samples that fits the ideal batch sizes after %s iterations. Checking balance...", outer_loop, inner_loop))
}
# match pid to batch
pid_to_batches = c()
b2 = lapply(new_sets, unlist)
for(i in 1:length(b2)){
pids = names(b2[[i]])
pid_to_batch = rep(i, length(pids))
names(pid_to_batch) = pids
pid_to_batches = c(pid_to_batches, pid_to_batch)
}
curr_batch_pid[,batch := pid_to_batches[pid]]
# check if batches are balanced
if(max_full){
# if max_full, ignore the smallest batch when checking batch balance
curr_sizes = curr_batch_pid[,list(total=sum(N)), by=batch]
smallest_batch = curr_sizes[which.min(total), batch]
batches_to_check = curr_batch_pid[batch != smallest_batch]
}else{
batches_to_check = curr_batch_pid
}
check_batches = check_batch_balance(batches_to_check, balance_strictness, max_full, balance_vars)
balanced_batches = check_batches$success
batch_assignments = curr_batch_pid
outer_loop = outer_loop + 1
inner_loop = 1
# keep track of which variables failed balancing (only for max_full)
if(max_full){
for(v in check_batches$failed){
failed_balancing[[v]] = failed_balancing[[v]] + 1
}
}
}else{
inner_loop = inner_loop + 1
if(inner_loop>max_inner_loop_iter & !feasible_batches){
new_batch_sizes = id_feasible_batch_sizes(curr_batch_pid, max_n_per_batch, max_full)
batch_sizes = new_batch_sizes
warning(sprintf("With %s total samples and maximum %s samples per batch, the ideal number of samples per batch are as follows:\n%s\nHowever, after %s iterations, no combination of samples was found to fit these batch sizes. Trying again with the following batch sizes:\n%s",
sum(curr_batch_pid[,N]),
max_n_per_batch,
paste0(batch_sizes, collapse=', '),
inner_loop,
paste0(batch_sizes, collapse=', ')))
feasible_batches = T
}
if(outer_loop > max_outer_loop_iter){
if(verbose){
writeLines(paste0(batch_sizes, collapse=', '))
}
if(strict_size){
stop(sprintf("With %s total samples, maximum %s samples per batch, and target batch sizes printed above, well-balanced batches were not found in %s candidate batches. You are currently requiring all batches to have samples from more than one group for all of the following variables:\n    %s\nHope for better luck and rerun the script - OR - try removing the least important variable from this list using the --vars-to-balance flag and rerun the script.",
sum(curr_batch_pid[,N]),
max_n_per_batch,
outer_loop-1,
paste0(balance_vars, collapse=', ')))
}
if(max_full){
too_strict = names(which.max(failed_balancing))
message(sprintf("With %s total samples and %s samples per batch whenever possible, balanced batches were not found in %s candidate batches. The current balance strictness parameters are as follows:\n",
sum(curr_batch_pid[,N]),
max_n_per_batch,
outer_loop-1))
print(balance_strictness)
message(sprintf("Decreasing balance strictness for %s by 1.", too_strict))
balance_strictness[[too_strict]] = balance_strictness[[too_strict]] - 1
outer_loop = 1
inner_loop = 1
# reset table
for(v in balance_vars){
failed_balancing[[v]] = 0
}
}
}
}
}
return(batch_assignments)
}
roxygenise()
roxygenise()
roxygenise()
use_mit_license()
library(usethis)
use_mit_license()
use_vignette()
